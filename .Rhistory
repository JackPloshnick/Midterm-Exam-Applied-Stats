setwd("~/Applied Statistical Programming/poisson.lik")
library(devtools)
library(roxygen2)
current.code <- as.package("Poisson")
load_all(current.code)
document(current.code)
current.code <- as.package("anRpackage")
setwd("~/GitHub/Midterm-Exam-Applied-Stats")
current.code <- as.package("anRpackage")
load_all(current.code)
document(current.code)
current.code <- as.package("anRpackage")
load_all(current.code)
document(current.code)
current.code <- as.package("anRpackage")
load_all(current.code)
document(current.code)
load("C:/Users/jackp/Documents/GitHub/Midterm-Exam-Applied-Stats/anRpackage/data/current.code.rda")
current.code <- as.package("anRpackage")
load_all(current.code)
document(current.code)
package.skeleton()
setwd("~/Applied Statistical Programming/midterm help")
package.skeleton()
current.code <- as.package("anRPackage")
load_all(current.code)
document(current.code)
current.code <- as.package("anRPackage")
load_all(current.code)
document(current.code)
setClass(Class="Rasch",  #Sets S4 class of Rasch
representation = representation(
name = "character", # three slots as specified in problem set
a_value = "vector",
y_j_value = "vector"
),
prototype = prototype(
name = c(), #default values are empty
a_value=  c(),
y_j_value  = c()
)
)
setValidity("Rasch", function(object){
valuesLength= (length(object@a_value)== length(object@y_j_value))#ensures values the same length
CarTest = function(object){
z<- (object@y_j_value ==1 | object@y_j_value ==0 ) #ensures only values of 0 or 1 possible as y_j value
return(z)
}
if(!valuesLength | !all(CarTest(object))){ #returns error if chosen Rasch is broken
stop("Rasch not valid")
}
})
setMethod("initialize", "Rasch", function(.Object, ...) { #initilize method
value = callNextMethod()
validObject(value)
return(value)
})
########### Making probability function
## it works. But I don't know how to do it in apply
PQ= vector(mode="numeric", length= length(test@y_j_value)) #creates blank PQ vector
P= vector(mode="numeric", length= length(test@y_j_value)) #creates blank P vector
Probability<- function(raschObj, theta){
for(i in 1:length(raschObj@y_j_value)){ #this loop calculates the P values
P.i.j= (exp(theta - raschObj@a_value[i]))/(1+exp(theta - raschObj@a_value[i])) #formula from paper
P[i]= P.i.j}
for(i in 1:length(raschObj@y_j_value)){#this loop calculates PQ values
if(raschObj@ y_j_value[i]==1){#if y==1, use P.i.j value
P.i.j= (exp(theta - raschObj@a_value[i]))/(1+exp(theta - raschObj@a_value[i]))
PQ[i]<- P.i.j # P
}
if(raschObj@ y_j_value[i]==0){ #if y==0, use 1- p.i.j value
P.i.j= (exp(theta - raschObj@a_value[i]))/(1+exp(theta - raschObj@a_value[i]))
PQ[i]<- 1-P.i.j # Q
}
}
return(list(P, PQ)) #this returns both vectors
}
############## Liklihood function
Liklihood<- function(raschObj, theta){
P_Q_values = Probability(raschObj,theta)[[2]] #This gets the PQ values from Probability function
for(i in 1:length(raschObj@y_j_value)){#this loop calculates PQ values
if(raschObj@y_j_value[i]==1){#if y==1, use P.i.j value
P_Q_values[i] = P_Q_values[i]^(raschObj@y_j_value[i])
}
if(raschObj@y_j_value[i]==0){ #if y==0, use 1- p.i.j value
P_Q_values[i] = P_Q_values[i]^(1-raschObj@y_j_value[i])
}
x<- prod(P_Q_values) # Multiplies them all together
return(x)
}
}
####### Prior
Prior<- function(theta){ #takes in theta
height<- dnorm(theta, mean=0, sd=3) #calculates Height
return(height) #returns Height
}
###### EAP
EAP<- function(raschObj, lower, upper){
myFunction <- function(raschObj, theta){# I am not quite sure what the question is asking
f= theta* Liklihood(raschObj, theta) *Prior(theta) #I interpret the question to mean, integrate over the function
## theta* liklihood(theta)* Prior(theta). This is the function I am trying to integrate. If the problem asked for me to
### integrerate over a diferent formula, I can do that, I just don't understand the question.
return(f)
}
g_of_theta = integrate(myFunction, raschObj= raschObj, lower= lower, upper= upper)#integrates over function
return(g_of_theta)
}
### Print function
setMethod("print", "Rasch",
function(x){
print(x@name) #prints name
z<- EAP(x,-6,6) #does EAP calculation
print(z$value) #prints value
print(z$abs.error) #prints absolute error
})
current.code <- as.package("anRPackage")
load_all(current.code)
document(current.code)
current.code <- as.package("anRPackage")
load_all(current.code)
document(current.code)
current.code <- as.package("anRpackage")
load_all(current.code)
document(current.code)
setwd("~/GitHub/Midterm-Exam-Applied-Stats")
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
?Liklihood
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
?Liklihood
library(devtools)
library(roxygen2)
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
?Liklihood
a= c(1,2,3,4,5,4,3,2,1) #difficulty
y= c(1,1,0,0,0,0,1,1,1) #answer. 1 is correct. 0 is incorrect
test<- new('Rasch', name= "Steve", a_value= a, y_j_value= y  )
Probability(test, -6)
Liklihood(test, 5)
Prior(45)
z<- EAP(test,-6,6)
z
print(test)
document(current.code)
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
current.code <- as.package("Midterm")
load_all(current.code)
document(current.code)
?Liklihood
current.code <- as.package("Midterm")
load_all(current.code)
a= c(1,2,3,4,5,4,3,2,1) #difficulty
y= c(1,1,0,0,0,0,1,1,1) #answer. 1 is correct. 0 is incorrect
test<- new('Rasch', name= "Steve", a_value= a, y_j_value= y  )
Probability(test, 4)
Liklihood(test, 4)
Prior(4)
z<- EAP(test,4,4)
print(test) #integral from -6 to 6
warnings()
PQ= vector(mode="numeric", length= length(test@y_j_value)) #creates blank PQ vector
P= vector(mode="numeric", length= length(test@y_j_value)) #creates blank P vector
?sapply
P.i.j= (exp(theta - raschObj@a_value[i]))/(1+exp(theta - raschObj@a_value[i])) #formula from paper
theta= 6
P.i.j= (exp(theta - raschObj@a_value[i]))/(1+exp(theta - raschObj@a_value[i])) #formula from paper
raschObj= test
P.i.j= (exp(theta - raschObj@a_value[i]))/(1+exp(theta - raschObj@a_value[i])) #formula from paper
sapply(PQ, (exp(theta - raschObj@a_value))/(1+exp(theta - raschObj@a_value)) )
sapply(raschObj, (exp(theta - raschObj@a_value))/(1+exp(theta - raschObj@a_value)) )
sapply(test, (exp(theta - raschObj@a_value))/(1+exp(theta - raschObj@a_value)) )
